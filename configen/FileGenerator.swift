//
//  FileGenerator.swift
//  configen
//
//  Created by Dónal O'Brien on 11/08/2016.
//  Copyright © 2016 Kin + Carta. All rights reserved.
//

import Foundation

struct FileGenerator {

  struct Error: Swift.Error {
    let message: String
  }

  let options: Options

  var autoGenerationComment: String {
    return """
    // auto-generated by \(options.appName)\n// to add or remove properties, edit the mapping file: '\(options.inputHintsFilePath)'.\n// README: https://github.com/theappbusiness/ConfigGenerator/blob/master/README.md\n\n
    """
  }

  func generateHeaderFile(withTemplate template: HeaderTemplate) throws {
    var headerBodyContent = ""
    try options.sortedHints().forEach { hint in
      let headerLine = methodDeclaration(for: hint, template: template)
      headerBodyContent.append("\n" + headerLine + ";" + "\n")
    }

    var headerBody = template.headerBody
    headerBody.replace(token: template.bodyToken, withString: headerBodyContent)
    let headerOutputString = autoGenerationComment + template.headerImportStatements + headerBody
    try headerOutputString.write(toFile: template.outputHeaderFileName, atomically: true, encoding: String.Encoding.utf8)
  }

  func generateImplementationFile(withTemplate template: ImplementationTemplate) throws {
    var implementationBodyContent = ""
    try options.sortedHints().forEach { hint in
      let implementationLine = try methodImplementation(for: hint, template: template)
      implementationBodyContent.append("\n" + implementationLine + "\n")
    }

    var implementationBody = template.implementationBody
    implementationBody.replace(token: template.bodyToken, withString: implementationBodyContent)
    let implementationOutputString = autoGenerationComment + template.implementationImportStatements + implementationBody
    try implementationOutputString.write(toFile: template.outputImplementationFileName, atomically: true, encoding: String.Encoding.utf8)
  }

  private func methodDeclaration(for hint: Options.Hint, template: HeaderTemplate) -> String {
    var line = ""

    switch hint.type {
    case "Double":
      line = template.doubleDeclaration

    case "Int":
      line = template.integerDeclaration

    case "String":
      line = template.stringDeclaration

    case "Bool":
      line = template.booleanDeclaration

    case "URL":
      line = template.urlDeclaration

    default:
      line = template.customDeclaration
      line.replace(token: template.customTypeToken, withString: hint.type)
    }

    line.replace(token: template.variableNameToken, withString: hint.variableName)

    return line
  }

  private func methodImplementation(for hint: Options.Hint, template: ImplementationTemplate) throws -> String {

    let plistDictionary = try options.plistDictionary()
    guard let value = plistDictionary[hint.variableName] else {
        throw Error(message: "No configuration setting for variable name: \(hint.variableName)")
    }

    var line = ""

    switch hint.type {
    case "Double":
      line = template.doubleImplementation

    case "Int":
      line = template.integerImplementation

    case "String":
      line = template.stringImplementation

    case "Bool":
      guard let boolValue = value as? Bool else {
        throw Error(message: "Value '\(value)' is not a Bool!")
      }
      let boolString = boolValue ? template.trueString : template.falseString
      line = template.booleanImplementation
      line.replace(token: template.valueToken, withString: boolString)

    case "URL":
      guard let url = URL(string: "\(value)") else {
        throw Error(message: "Value '\(value)' is not a URL!")
      }
      guard url.host != nil else {
        throw Error(message: "Found URL without host: \(url) for setting: \(hint.variableName)")
      }
      line = template.urlImplementation
    default:
	  // Check if this is an Array type
	  if case let .success(arrayElementType) = ArrayUtils.isValidArrayType(hint.type) {
		let arrayString = ArrayUtils.transformArrayToString(arrayElementType, rawValue: value)
		line = template.customImplementation
		line.replace(token: template.variableNameToken, withString: hint.variableName)
		line.replace(token: template.customTypeToken, withString: hint.type)
		line.replace(token: template.valueToken, withString: arrayString)
		return line
	  }
      guard value is String else {
        throw Error(message: "Value (\(value)) must be a string in order to be used by custom type \(hint.type)")
      }
      line = template.customImplementation
      line.replace(token: template.customTypeToken, withString: hint.type)
    }

    line.replace(token: template.variableNameToken, withString: hint.variableName)
    line.replace(token: template.valueToken, withString: "\(value)")

    return line
  }
}

extension String {
  mutating func replace(token: String, withString string: String) {
    self = replacingOccurrences(of: token, with: string)
  }

  var trimmed: String {
    return (self as NSString).trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
  }

  func match(regex: String) -> Bool {
    guard let regex = try? NSRegularExpression(pattern: regex, options: .caseInsensitive) else {
      return false
    }

    let matches = regex.matches(in: self, options: [], range: NSRange(location: 0, length: self.utf16.count))
    return !matches.isEmpty
  }
}
